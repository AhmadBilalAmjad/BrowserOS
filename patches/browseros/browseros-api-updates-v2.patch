From 6dba6670743ee9f55c029870a0561d1e4de05ad2 Mon Sep 17 00:00:00 2001
From: Nikhil Sonti <nikhilsv92@gmail.com>
Date: Fri, 5 Sep 2025 10:33:27 -0700
Subject: [PATCH] browseros api updates v2: execute javascript, highlights,
 screenshot with dimension

---
 .../api/browser_os/browser_os_api.cc          | 307 ++++++++++++++++--
 .../api/browser_os/browser_os_api.h           |  59 +++-
 .../api/browser_os/browser_os_api_helpers.cc  | 270 ++++++++++++++-
 .../api/browser_os/browser_os_api_helpers.h   |  21 ++
 .../api/browser_os/browser_os_api_utils.cc    |   2 +-
 .../api/browser_os/browser_os_api_utils.h     |   2 +
 .../browser_os_snapshot_processor.cc          |   4 +
 .../chrome_extensions_browser_api_provider.cc |   1 +
 chrome/common/extensions/api/browser_os.idl   |  43 +++
 .../extension_function_histogram_value.h      |   3 +
 10 files changed, 680 insertions(+), 32 deletions(-)

diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api.cc b/chrome/browser/extensions/api/browser_os/browser_os_api.cc
index 5242a1c3f930c..789218f333a04 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api.cc
@@ -11,6 +11,7 @@
 #include <vector>
 
 #include "base/functional/bind.h"
+#include "base/threading/platform_thread.h"
 #include "chrome/browser/profiles/profile.h"
 #include "components/prefs/pref_service.h"
 #include "base/json/json_writer.h"
@@ -178,6 +179,7 @@ ExtensionFunction::ResponseAction BrowserOSGetInteractiveSnapshotFunction::Run()
   }
   
   content::WebContents* web_contents = tab_info->web_contents;
+  web_contents_ = web_contents;  // Store for later use in OnSnapshotProcessed
   
   // Note: We don't need to get scale factors here!
   // The accessibility tree provides bounds in CSS pixels (logical pixels),
@@ -194,6 +196,18 @@ ExtensionFunction::ResponseAction BrowserOSGetInteractiveSnapshotFunction::Run()
     LOG(INFO) << "Viewport size: " << viewport_size_.ToString();
   }
 
+  // Check frame stability before requesting snapshot
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh || !rfh->IsRenderFrameLive() || !rfh->IsActive()) {
+    LOG(WARNING) << "[browseros] Frame not stable for AX snapshot - skipping";
+    browser_os::InteractiveSnapshot empty_snapshot;
+    empty_snapshot.snapshot_id = next_snapshot_id_++;
+    empty_snapshot.timestamp = base::Time::Now().InMillisecondsFSinceUnixEpoch();
+    empty_snapshot.processing_time_ms = 0;
+    return RespondNow(ArgumentList(
+        browser_os::GetInteractiveSnapshot::Results::Create(empty_snapshot)));
+  }
+  
   // Request accessibility tree snapshot
   web_contents->RequestAXTreeSnapshot(
       base::BindOnce(
@@ -204,12 +218,37 @@ ExtensionFunction::ResponseAction BrowserOSGetInteractiveSnapshotFunction::Run()
       /* max_nodes= */ 0,  // No limit
       /* timeout= */ base::TimeDelta(),
       content::WebContents::AXTreeSnapshotPolicy::kAll);
+      // content::WebContents::AXTreeSnapshotPolicy::kSameOriginDirectDescendants);
 
   return RespondLater();
 }
 
 void BrowserOSGetInteractiveSnapshotFunction::OnAccessibilityTreeReceived(
     ui::AXTreeUpdate& tree_update) {
+  // Double-check frame is still valid before processing
+  if (!web_contents_) {
+    LOG(WARNING) << "[browseros] WebContents gone during AX snapshot callback";
+    browser_os::InteractiveSnapshot empty_snapshot;
+    empty_snapshot.snapshot_id = next_snapshot_id_++;
+    empty_snapshot.timestamp = base::Time::Now().InMillisecondsFSinceUnixEpoch();
+    empty_snapshot.processing_time_ms = 0;
+    Respond(ArgumentList(
+        browser_os::GetInteractiveSnapshot::Results::Create(empty_snapshot)));
+    return;
+  }
+  
+  content::RenderFrameHost* rfh = web_contents_->GetPrimaryMainFrame();
+  if (!rfh || !rfh->IsRenderFrameLive()) {
+    LOG(WARNING) << "[browseros] Frame became unstable during AX snapshot callback";
+    browser_os::InteractiveSnapshot empty_snapshot;
+    empty_snapshot.snapshot_id = next_snapshot_id_++;
+    empty_snapshot.timestamp = base::Time::Now().InMillisecondsFSinceUnixEpoch();
+    empty_snapshot.processing_time_ms = 0;
+    Respond(ArgumentList(
+        browser_os::GetInteractiveSnapshot::Results::Create(empty_snapshot)));
+    return;
+  }
+  
   // Simple API layer - just delegates to the processor
   SnapshotProcessor::ProcessAccessibilityTree(
       tree_update,
@@ -620,10 +659,16 @@ ExtensionFunction::ResponseAction BrowserOSSendKeysFunction::Run() {
 
 // Implementation of BrowserOSCaptureScreenshotFunction
 
+BrowserOSCaptureScreenshotFunction::BrowserOSCaptureScreenshotFunction() = default;
+BrowserOSCaptureScreenshotFunction::~BrowserOSCaptureScreenshotFunction() = default;
+
 ExtensionFunction::ResponseAction BrowserOSCaptureScreenshotFunction::Run() {
   std::optional<browser_os::CaptureScreenshot::Params> params =
       browser_os::CaptureScreenshot::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params);
+  
+  // Store whether to show highlights
+  show_highlights_ = params->show_highlights.value_or(false);
 
   // Get the target tab
   std::string error_message;
@@ -635,6 +680,8 @@ ExtensionFunction::ResponseAction BrowserOSCaptureScreenshotFunction::Run() {
   }
   
   content::WebContents* web_contents = tab_info->web_contents;
+  web_contents_ = web_contents;
+  tab_id_ = tab_info->tab_id;
   
   // Get the render widget host view
   content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
@@ -655,51 +702,120 @@ ExtensionFunction::ResponseAction BrowserOSCaptureScreenshotFunction::Run() {
   // Get the view bounds to determine the size
   gfx::Rect view_bounds = rwhv->GetViewBounds();
   
-  // Determine max thumbnail size
-  // If thumbnailSize is provided, use minimum of it and viewport dimensions
-  // Otherwise, use viewport size (no scaling)
-  int max_dimension;
-  if (params->thumbnail_size) {
-    // Take minimum of requested size and viewport dimensions
-    int viewport_max = std::max(view_bounds.width(), view_bounds.height());
-    max_dimension = std::min(static_cast<int>(*params->thumbnail_size), viewport_max);
-    LOG(INFO) << "[browseros] CaptureScreenshot: Using thumbnail size: " << max_dimension 
-              << " (requested: " << *params->thumbnail_size 
-              << ", viewport max: " << viewport_max << ")";
+  // Check if exact width and height are specified
+  if (params->width && params->height) {
+    // Use exact dimensions without preserving aspect ratio
+    use_exact_dimensions_ = true;
+    target_size_ = gfx::Size(static_cast<int>(*params->width), 
+                            static_cast<int>(*params->height));
+    LOG(INFO) << "[browseros] CaptureScreenshot: Using exact dimensions: "
+              << target_size_.width() << "x" << target_size_.height();
   } else {
-    // No thumbnail size specified, use viewport dimensions
-    max_dimension = std::max(view_bounds.width(), view_bounds.height());
-    LOG(INFO) << "[browseros] CaptureScreenshot: Using viewport size: " << max_dimension;
+    // Fall back to original behavior with thumbnailSize
+    use_exact_dimensions_ = false;
+    
+    // Determine max thumbnail size
+    // If thumbnailSize is provided, use minimum of it and viewport dimensions
+    // Otherwise, use viewport size (no scaling)
+    int max_dimension;
+    if (params->thumbnail_size) {
+      // Take minimum of requested size and viewport dimensions
+      int viewport_max = std::max(view_bounds.width(), view_bounds.height());
+      max_dimension = std::min(static_cast<int>(*params->thumbnail_size), viewport_max);
+      LOG(INFO) << "[browseros] CaptureScreenshot: Using thumbnail size: " << max_dimension 
+                << " (requested: " << *params->thumbnail_size 
+                << ", viewport max: " << viewport_max << ")";
+    } else {
+      // No thumbnail size specified, use viewport dimensions
+      max_dimension = std::max(view_bounds.width(), view_bounds.height());
+      LOG(INFO) << "[browseros] CaptureScreenshot: Using viewport size: " << max_dimension;
+    }
+    
+    gfx::Size thumbnail_size = view_bounds.size();
+    
+    // Scale down proportionally if needed
+    if (thumbnail_size.width() > max_dimension || 
+        thumbnail_size.height() > max_dimension) {
+      float scale = std::min(
+          static_cast<float>(max_dimension) / thumbnail_size.width(),
+          static_cast<float>(max_dimension) / thumbnail_size.height());
+      thumbnail_size = gfx::ScaleToFlooredSize(thumbnail_size, scale);
+    }
+    
+    target_size_ = thumbnail_size;
+  }
+  
+  // Store target size for later use
+  
+  // Draw highlights first, then capture after a short delay
+  DrawHighlightsAndCapture();
+  
+  return RespondLater();
+}
+
+void BrowserOSCaptureScreenshotFunction::DrawHighlightsAndCapture() {
+  // Only draw highlights if requested via the showHighlights flag
+  if (show_highlights_) {
+    // Check if we have snapshot data for this tab to draw highlights
+    auto tab_it = GetNodeIdMappings().find(tab_id_);
+    if (tab_it != GetNodeIdMappings().end() && !tab_it->second.empty()) {
+      LOG(INFO) << "[browseros] Drawing highlights for screenshot with " 
+                << tab_it->second.size() << " interactive elements";
+      ShowHighlights(web_contents_, tab_it->second, true /* show_labels */);
+    } else {
+      LOG(INFO) << "[browseros] No snapshot data available for highlighting";
+    }
+    
+    // Use PostDelayedTask to allow the renderer to paint the highlights
+    // This lets the event loop run and process the DOM changes
+    // Use scoped_refptr to keep the function alive
+    base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+        FROM_HERE,
+        base::BindOnce(&BrowserOSCaptureScreenshotFunction::CaptureScreenshotNow,
+                       base::WrapRefCounted(this)),
+        base::Milliseconds(1000));  // Give enough time for JS execution and paint
+  } else {
+    // No highlights needed, capture immediately
+    CaptureScreenshotNow();
+  }
+}
+
+void BrowserOSCaptureScreenshotFunction::CaptureScreenshotNow() {
+  if (!web_contents_) {
+    Respond(Error("Web contents destroyed"));
+    return;
   }
   
-  gfx::Size thumbnail_size = view_bounds.size();
+  content::RenderFrameHost* rfh = web_contents_->GetPrimaryMainFrame();
+  if (!rfh) {
+    Respond(Error("No render frame"));
+    return;
+  }
   
-  // Scale down proportionally if needed
-  if (thumbnail_size.width() > max_dimension || 
-      thumbnail_size.height() > max_dimension) {
-    float scale = std::min(
-        static_cast<float>(max_dimension) / thumbnail_size.width(),
-        static_cast<float>(max_dimension) / thumbnail_size.height());
-    thumbnail_size = gfx::ScaleToFlooredSize(thumbnail_size, scale);
+  content::RenderWidgetHost* rwh = rfh->GetRenderWidgetHost();
+  if (!rwh) {
+    Respond(Error("No render widget host"));
+    return;
   }
   
-  // For macOS, we need to use a different approach since GrabWindowSnapshot
-  // expects a window, not a view. Let's use CopyFromSurface instead.
   content::RenderWidgetHostImpl* rwhi = 
       static_cast<content::RenderWidgetHostImpl*>(rwh);
   
-  // Request a copy of the surface
+  // Request the screenshot
   rwhi->GetView()->CopyFromSurface(
       gfx::Rect(),  // Empty rect means copy entire surface
-      thumbnail_size,
+      target_size_,
       base::BindOnce(&BrowserOSCaptureScreenshotFunction::OnScreenshotCaptured,
                      this));
-  
-  return RespondLater();
 }
 
 void BrowserOSCaptureScreenshotFunction::OnScreenshotCaptured(
     const SkBitmap& bitmap) {
+  // Clean up the highlights immediately after capture (only if we added them)
+  if (show_highlights_ && web_contents_) {
+    RemoveHighlights(web_contents_);
+  }
+  
   if (bitmap.empty()) {
     Respond(Error("Failed to capture screenshot"));
     return;
@@ -1011,5 +1127,140 @@ ExtensionFunction::ResponseAction BrowserOSGetVersionNumberFunction::Run() {
       browser_os::GetVersionNumber::Results::Create(version)));
 }
 
+// BrowserOSExecuteJavaScriptFunction
+ExtensionFunction::ResponseAction BrowserOSExecuteJavaScriptFunction::Run() {
+  std::optional<browser_os::ExecuteJavaScript::Params> params =
+      browser_os::ExecuteJavaScript::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Get the target tab
+  std::string error_message;
+  auto tab_info = GetTabFromOptionalId(params->tab_id, browser_context(),
+                                       include_incognito_information(),
+                                       &error_message);
+  if (!tab_info) {
+    return RespondNow(Error(error_message));
+  }
+  
+  content::WebContents* web_contents = tab_info->web_contents;
+  
+  // Get the primary main frame
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh) {
+    return RespondNow(Error("No render frame"));
+  }
+  
+  LOG(INFO) << "[browseros] ExecuteJavaScript: Executing code in tab " << tab_info->tab_id;
+  
+  // Convert JavaScript code string to UTF16
+  std::u16string js_code = base::UTF8ToUTF16(params->code);
+  
+  // Execute the JavaScript code using ExecuteJavaScriptForTests
+  // This will return the result of the execution
+  rfh->ExecuteJavaScriptForTests(
+      js_code,
+      base::BindOnce(&BrowserOSExecuteJavaScriptFunction::OnJavaScriptExecuted,
+                     this),
+      /*honor_js_content_settings=*/false);
+  
+  return RespondLater();
+}
+
+void BrowserOSExecuteJavaScriptFunction::OnJavaScriptExecuted(base::Value result) {
+  LOG(INFO) << "[browseros] ExecuteJavaScript: Execution completed";
+
+  if (result.is_none()) {
+      // JavaScript returned undefined or execution failed
+      // Return an empty object instead of NONE to satisfy the validator
+      result = base::Value(base::Value::Type::DICT);
+  }
+  
+  // Return the result directly
+  Respond(ArgumentList(
+      browser_os::ExecuteJavaScript::Results::Create(result)));
+}
+
+// Implementation of BrowserOSClickCoordinatesFunction
+ExtensionFunction::ResponseAction BrowserOSClickCoordinatesFunction::Run() {
+  std::optional<browser_os::ClickCoordinates::Params> params =
+      browser_os::ClickCoordinates::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Get the target tab
+  std::string error_message;
+  auto tab_info = GetTabFromOptionalId(params->tab_id, browser_context(),
+                                       include_incognito_information(),
+                                       &error_message);
+  if (!tab_info) {
+    LOG(ERROR) << "[browseros] ClickCoordinates: " << error_message;
+    browser_os::InteractionResponse response;
+    response.success = false;
+    return RespondNow(ArgumentList(
+        browser_os::ClickCoordinates::Results::Create(response)));
+  }
+  
+  content::WebContents* web_contents = tab_info->web_contents;
+  
+  // Create the click point from the coordinates
+  gfx::PointF click_point(params->x, params->y);
+  
+  LOG(INFO) << "[browseros] ClickCoordinates: Clicking at (" 
+            << params->x << ", " << params->y << ")";
+  
+  // Perform the click with change detection
+  bool success = ClickCoordinatesWithDetection(web_contents, click_point);
+  
+  // Prepare the response
+  browser_os::InteractionResponse response;
+  response.success = success;
+  
+  LOG(INFO) << "[browseros] ClickCoordinates: Result = " 
+            << (success ? "success" : "no change detected");
+  
+  return RespondNow(ArgumentList(
+      browser_os::ClickCoordinates::Results::Create(response)));
+}
+
+// Implementation of BrowserOSTypeAtCoordinatesFunction  
+ExtensionFunction::ResponseAction BrowserOSTypeAtCoordinatesFunction::Run() {
+  std::optional<browser_os::TypeAtCoordinates::Params> params =
+      browser_os::TypeAtCoordinates::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Get the target tab
+  std::string error_message;
+  auto tab_info = GetTabFromOptionalId(params->tab_id, browser_context(),
+                                       include_incognito_information(),
+                                       &error_message);
+  if (!tab_info) {
+    LOG(ERROR) << "[browseros] TypeAtCoordinates: " << error_message;
+    browser_os::InteractionResponse response;
+    response.success = false;
+    return RespondNow(ArgumentList(
+        browser_os::TypeAtCoordinates::Results::Create(response)));
+  }
+  
+  content::WebContents* web_contents = tab_info->web_contents;
+  
+  // Create the click point from the coordinates
+  gfx::PointF click_point(params->x, params->y);
+  
+  LOG(INFO) << "[browseros] TypeAtCoordinates: Clicking at (" 
+            << params->x << ", " << params->y << ") and typing: " << params->text;
+  
+  // Perform the click and type operation
+  bool success = TypeAtCoordinatesWithDetection(web_contents, click_point, params->text);
+  
+  // Prepare the response
+  browser_os::InteractionResponse response;
+  response.success = success;
+  
+  LOG(INFO) << "[browseros] TypeAtCoordinates: Result = " 
+            << (success ? "success" : "failed");
+  
+  return RespondNow(ArgumentList(
+      browser_os::TypeAtCoordinates::Results::Create(response)));
+}
+
 }  // namespace api
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api.h b/chrome/browser/extensions/api/browser_os/browser_os_api.h
index 27721d9b0b9a0..c267a22c45ca8 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api.h
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api.h
@@ -7,6 +7,7 @@
 
 #include <cstdint>
 
+#include "base/memory/raw_ptr.h"
 #include "base/values.h"
 #include "chrome/browser/extensions/api/browser_os/browser_os_api_utils.h"
 #include "chrome/browser/extensions/api/browser_os/browser_os_content_processor.h"
@@ -68,6 +69,9 @@ class BrowserOSGetInteractiveSnapshotFunction : public ExtensionFunction {
   
   // Viewport size for checking visibility
   gfx::Size viewport_size_;
+  
+  // Web contents for drawing bounding boxes
+  raw_ptr<content::WebContents> web_contents_ = nullptr;
 };
 
 class BrowserOSClickFunction : public ExtensionFunction {
@@ -179,16 +183,25 @@ class BrowserOSCaptureScreenshotFunction : public ExtensionFunction {
  public:
   DECLARE_EXTENSION_FUNCTION("browserOS.captureScreenshot", BROWSER_OS_CAPTURESCREENSHOT)
 
-  BrowserOSCaptureScreenshotFunction() = default;
+  BrowserOSCaptureScreenshotFunction();
 
  protected:
-  ~BrowserOSCaptureScreenshotFunction() override = default;
+  ~BrowserOSCaptureScreenshotFunction() override;
 
   // ExtensionFunction:
   ResponseAction Run() override;
   
  private:
+  void DrawHighlightsAndCapture();
+  void CaptureScreenshotNow();
   void OnScreenshotCaptured(const SkBitmap& bitmap);
+  
+  // Store web contents and tab id for highlight operations
+  raw_ptr<content::WebContents> web_contents_ = nullptr;
+  int tab_id_ = -1;
+  gfx::Size target_size_;
+  bool show_highlights_ = false;
+  bool use_exact_dimensions_ = false;
 };
 
 class BrowserOSGetSnapshotFunction : public ExtensionFunction {
@@ -275,6 +288,48 @@ class BrowserOSGetVersionNumberFunction : public ExtensionFunction {
   ResponseAction Run() override;
 };
 
+class BrowserOSExecuteJavaScriptFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("browserOS.executeJavaScript", BROWSER_OS_EXECUTEJAVASCRIPT)
+
+  BrowserOSExecuteJavaScriptFunction() = default;
+
+ protected:
+  ~BrowserOSExecuteJavaScriptFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+  
+ private:
+  void OnJavaScriptExecuted(base::Value result);
+};
+
+class BrowserOSClickCoordinatesFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("browserOS.clickCoordinates", BROWSER_OS_CLICKCOORDINATES)
+
+  BrowserOSClickCoordinatesFunction() = default;
+
+ protected:
+  ~BrowserOSClickCoordinatesFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+class BrowserOSTypeAtCoordinatesFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("browserOS.typeAtCoordinates", BROWSER_OS_TYPEATCOORDINATES)
+
+  BrowserOSTypeAtCoordinatesFunction() = default;
+
+ protected:
+  ~BrowserOSTypeAtCoordinatesFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
 }  // namespace api
 }  // namespace extensions
 
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc
index d05a75dd626e9..ad9b5cabf9b4e 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h"
 
 #include "base/strings/string_number_conversions.h"
+#include "base/strings/stringprintf.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/task/sequenced_task_runner.h"
 #include "chrome/browser/extensions/api/browser_os/browser_os_api_utils.h"
@@ -119,7 +120,7 @@ void VisualizeInteractionPoint(content::WebContents* web_contents,
   const float start_y = point.y() - (sin(angle) * distance);
   
   // Build the JavaScript code using string concatenation to avoid format string issues
-  std::string js_code = absl::StrFormat(
+  std::string js_code = base::StringPrintf(
       R"(
       (function() {
         var COLOR = '#FC661A';
@@ -971,5 +972,272 @@ bool KeyPressWithDetection(content::WebContents* web_contents,
   return changed;
 }
 
+// Helper to show highlights for clickable, typeable, and selectable elements that are in viewport
+void ShowHighlights(
+    content::WebContents* web_contents,
+    const std::unordered_map<uint32_t, NodeInfo>& node_mappings,
+    bool show_labels) {
+  
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh) return;
+  
+  // Filter nodes to only include:
+  // 1. Elements that are in viewport (using stored in_viewport field)
+  // 2. Elements that are clickable, typeable, or selectable (using stored node_type)
+  std::unordered_map<uint32_t, NodeInfo> filtered_nodes;
+  
+  for (const auto& [node_id, node_info] : node_mappings) {
+    // Check if element is in viewport using the stored field
+    if (!node_info.in_viewport) {
+      continue;  // Skip elements not in viewport
+    }
+    
+    // Check if element is clickable, typeable, or selectable using stored node_type
+    // Skip "other" interactive type as requested
+    if (node_info.node_type == browser_os::InteractiveNodeType::kClickable ||
+        node_info.node_type == browser_os::InteractiveNodeType::kTypeable ||
+        node_info.node_type == browser_os::InteractiveNodeType::kSelectable) {
+      filtered_nodes[node_id] = node_info;
+    }
+  }
+  
+  // If no nodes match our criteria, return early
+  if (filtered_nodes.empty()) {
+    LOG(INFO) << "[browseros] No interactive elements in viewport to highlight";
+    return;
+  }
+  
+  LOG(INFO) << "[browseros] Highlighting " << filtered_nodes.size() 
+            << " interactive elements in viewport (out of " << node_mappings.size() << " total)";
+  
+  // Use the original drawing implementation but with filtered nodes
+  
+  // Build JavaScript to draw all bounding boxes at once
+  std::string js_code = R"(
+    (function() {
+      // Remove any existing bounding boxes
+      document.querySelectorAll('.browseros-bbox').forEach(e => e.remove());
+      
+      // Create container for all bounding boxes
+      const container = document.createElement('div');
+      container.className = 'browseros-bbox-container';
+      container.style.cssText = `
+        position: fixed;
+        top: 0;
+        left: 0;
+        width: 100%;
+        height: 100%;
+        pointer-events: none;
+        z-index: 2147483647;
+      `;
+      
+      // Node data with bounds
+      const nodes = [
+  )";
+  
+  // Add filtered nodes with their bounds
+  bool first = true;
+  for (const auto& [node_id, node_info] : filtered_nodes) {
+    if (!first) js_code += ",";
+    first = false;
+    
+    js_code += base::StringPrintf(
+        R"(
+        {
+          id: %d,
+          x: %f,
+          y: %f,
+          width: %f,
+          height: %f,
+          role: "%s"
+        })",
+        node_id,
+        node_info.bounds.x(),
+        node_info.bounds.y(),
+        node_info.bounds.width(),
+        node_info.bounds.height(),
+        node_info.attributes.count("role") ? node_info.attributes.at("role").c_str() : "unknown"
+    );
+  }
+  
+  js_code += R"(
+      ];
+      
+      // Draw bounding boxes for all nodes in parallel
+      nodes.forEach(node => {
+        if (node.width <= 0 || node.height <= 0) return;
+        
+        const box = document.createElement('div');
+        box.className = 'browseros-bbox';
+        box.dataset.nodeId = node.id;
+        box.style.cssText = `
+          position: absolute;
+          left: ${node.x}px;
+          top: ${node.y}px;
+          width: ${node.width}px;
+          height: ${node.height}px;
+          border: 2px solid #1E40AF;
+          background: transparent;
+          box-sizing: border-box;
+        `;
+  )";
+  
+  if (show_labels) {
+    js_code += R"(
+        // Add label with node ID
+        const label = document.createElement('div');
+        label.style.cssText = `
+          position: absolute;
+          top: -22px;
+          left: 0;
+          background: #2563EB;
+          color: #FFFFFF;
+          padding: 3px 7px;
+          font-size: 14px;
+          font-family: monospace;
+          border-radius: 3px;
+          white-space: nowrap;
+          opacity: 0.9;
+        `;
+        label.textContent = node.id;
+        box.appendChild(label);
+    )";
+  }
+  
+  js_code += R"(
+        container.appendChild(box);
+      });
+      
+      document.body.appendChild(container);
+      
+      // Return count for verification
+      return nodes.length;
+    })();
+  )";
+  
+  // Execute the JavaScript
+  rfh->ExecuteJavaScriptForTests(
+      base::UTF8ToUTF16(js_code),
+      base::NullCallback(),
+      false);
+}
+
+// Helper to remove all bounding box highlights from the page
+void RemoveHighlights(content::WebContents* web_contents) {
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh) return;
+  
+  // JavaScript to remove all bounding box containers
+  std::string js_code = R"(
+    (function() {
+      // Remove all bounding box containers
+      document.querySelectorAll('.browseros-bbox-container').forEach(e => e.remove());
+      document.querySelectorAll('.browseros-bbox').forEach(e => e.remove());
+      
+      // Remove all highlight containers  
+      document.querySelectorAll('.browseros-highlight-container').forEach(e => e.remove());
+      document.querySelectorAll('.browseros-highlight').forEach(e => e.remove());
+      
+      // Remove any style elements we added
+      document.querySelectorAll('#browseros-highlight-styles').forEach(e => e.remove());
+      
+      return true;
+    })();
+  )";
+  
+  rfh->ExecuteJavaScriptForTests(
+      base::UTF8ToUTF16(js_code),
+      base::NullCallback(),
+      false);
+}
+
+// Helper to click at specific coordinates with change detection
+bool ClickCoordinatesWithDetection(content::WebContents* web_contents,
+                                   const gfx::PointF& point) {
+  LOG(INFO) << "[browseros] ClickCoordinatesWithDetection at (" 
+            << point.x() << ", " << point.y() << ")";
+  
+  // Perform coordinate click with change detection
+  bool changed = BrowserOSChangeDetector::ExecuteWithDetection(
+      web_contents,
+      [&]() { 
+        PointClick(web_contents, point);
+        // Optionally visualize the click point
+        VisualizeInteractionPoint(web_contents, point, 1500);
+      },
+      base::Milliseconds(300));
+  
+  LOG(INFO) << "[browseros] Click coordinates result: " 
+            << (changed ? "changed" : "no change");
+  return changed;
+}
+
+// Helper to type text after clicking at coordinates to focus element
+bool TypeAtCoordinatesWithDetection(content::WebContents* web_contents,
+                                    const gfx::PointF& point,
+                                    const std::string& text) {
+  LOG(INFO) << "[browseros] TypeAtCoordinatesWithDetection at (" 
+            << point.x() << ", " << point.y() << ") with text: " << text;
+  
+  // First click at the coordinates to focus the element
+  PointClick(web_contents, point);
+  
+  // Visualize the click point briefly
+  VisualizeInteractionPoint(web_contents, point, 1000);
+  
+  // Wait a moment for focus to be established
+  base::PlatformThread::Sleep(base::Milliseconds(100));
+  
+  // Now type the text with change detection
+  bool changed = BrowserOSChangeDetector::ExecuteWithDetection(
+      web_contents,
+      [&]() { 
+        NativeType(web_contents, text);
+      },
+      base::Milliseconds(300));
+  
+  // If native typing didn't work, try JavaScript injection to detect and type
+  if (!changed) {
+    LOG(INFO) << "[browseros] No change from native typing at coordinates, trying JS injection";
+    
+    // Execute JavaScript to find the focused element and set its value
+    content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+    if (rfh) {
+      std::string js_code = base::StringPrintf(R"(
+        (function() {
+          var focused = document.activeElement;
+          if (focused && (focused.tagName === 'INPUT' || 
+                         focused.tagName === 'TEXTAREA' || 
+                         focused.contentEditable === 'true')) {
+            if (focused.contentEditable === 'true') {
+              focused.textContent = '%s';
+            } else {
+              focused.value = '%s';
+            }
+            // Trigger input event
+            focused.dispatchEvent(new Event('input', { bubbles: true }));
+            focused.dispatchEvent(new Event('change', { bubbles: true }));
+            return true;
+          }
+          return false;
+        })();
+      )", text.c_str(), text.c_str());
+      
+      rfh->ExecuteJavaScriptForTests(
+          base::UTF8ToUTF16(js_code),
+          base::NullCallback(),
+          false);
+      
+      // Give it a moment to register
+      base::PlatformThread::Sleep(base::Milliseconds(50));
+      changed = true; // Assume success if we reached here
+    }
+  }
+  
+  LOG(INFO) << "[browseros] Type at coordinates result: " 
+            << (changed ? "success" : "failed");
+  return changed;
+}
+
 }  // namespace api
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h
index b5fd204753973..d6f632bb46258 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h
@@ -118,6 +118,27 @@ void VisualizeInteractionPoint(content::WebContents* web_contents,
                                int duration_ms = 3000,
                                float offset_range = 50.0f);
 
+// Helper to show highlights for clickable, typeable, and selectable elements that are in viewport
+// Only highlights elements that are actually visible and interactable
+void ShowHighlights(content::WebContents* web_contents,
+                                 const std::unordered_map<uint32_t, NodeInfo>& node_mappings,
+                                 bool show_labels = true);
+
+// Helper to remove all bounding box highlights from the page
+void RemoveHighlights(content::WebContents* web_contents);
+
+// Helper to click at specific coordinates with change detection
+// Returns true if the click caused a detectable change in the page
+bool ClickCoordinatesWithDetection(content::WebContents* web_contents,
+                                   const gfx::PointF& point);
+
+// Helper to type text after clicking at coordinates to focus element
+// First clicks at the coordinates to focus an element, then types the text
+// Returns true if the operation succeeded
+bool TypeAtCoordinatesWithDetection(content::WebContents* web_contents,
+                                    const gfx::PointF& point,
+                                    const std::string& text);
+
 }  // namespace api
 }  // namespace extensions
 
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc
index eccf01b1f9280..0c3a060fc70de 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc
@@ -20,7 +20,7 @@ namespace extensions {
 namespace api {
 
 // NodeInfo implementation
-NodeInfo::NodeInfo() : ax_node_id(0), ax_tree_id() {}
+NodeInfo::NodeInfo() : ax_node_id(0), ax_tree_id(), node_type(browser_os::InteractiveNodeType::kOther), in_viewport(false) {}
 NodeInfo::~NodeInfo() = default;
 NodeInfo::NodeInfo(const NodeInfo&) = default;
 NodeInfo& NodeInfo::operator=(const NodeInfo&) = default;
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h
index c632dc7a71585..f4fdcb73186cd 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h
@@ -50,6 +50,8 @@ struct NodeInfo {
   ui::AXTreeID ax_tree_id;  // Tree ID for change detection
   gfx::RectF bounds;  // Absolute bounds in CSS pixels
   std::unordered_map<std::string, std::string> attributes;  // All computed attributes
+  browser_os::InteractiveNodeType node_type;  // Cached node type to avoid recomputation
+  bool in_viewport;  // Whether the node is currently visible in viewport
 };
 
 // Global node ID mappings storage
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc b/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc
index 8dfc0cce77512..7fe193dc6d527 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc
@@ -420,6 +420,10 @@ void SnapshotProcessor::OnBatchProcessed(
     info.ax_tree_id = context->tree_id;  // Store tree ID for change detection
     info.bounds = node_data.absolute_bounds;
     info.attributes = node_data.attributes;  // Store all computed attributes
+    info.node_type = node_data.node_type;  // Store node type for efficient filtering
+    // Extract in_viewport from attributes (stored as "true"/"false" string)
+    auto viewport_it = node_data.attributes.find("in_viewport");
+    info.in_viewport = (viewport_it != node_data.attributes.end() && viewport_it->second == "true");
     GetNodeIdMappings()[context->tab_id][node_data.node_id] = info;
     
     // Log the mapping for debugging
diff --git a/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc b/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
index 6b3227c786686..3666bf5a0d2c8 100644
--- a/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
+++ b/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
@@ -28,6 +28,7 @@ void ChromeExtensionsBrowserAPIProvider::RegisterExtensionFunctions(
   registry->RegisterFunction<api::BrowserOSClickFunction>();
   registry->RegisterFunction<api::BrowserOSInputTextFunction>();
   registry->RegisterFunction<api::BrowserOSClearFunction>();
+  registry->RegisterFunction<api::BrowserOSExecuteJavaScriptFunction>();
 
   // Generated APIs from Chrome.
   api::ChromeGeneratedFunctionRegistry::RegisterAll(registry);
diff --git a/chrome/common/extensions/api/browser_os.idl b/chrome/common/extensions/api/browser_os.idl
index a8cbf0250d19a..23de5b35d5043 100644
--- a/chrome/common/extensions/api/browser_os.idl
+++ b/chrome/common/extensions/api/browser_os.idl
@@ -177,6 +177,9 @@ namespace browserOS {
   
   // Callback for getting version number
   callback GetVersionNumberCallback = void(DOMString version);
+  
+  // Callback for executeJavaScript
+  callback ExecuteJavaScriptCallback = void(any result);
 
   interface Functions {
     // Gets the full accessibility tree for a tab
@@ -276,15 +279,46 @@ namespace browserOS {
         optional long tabId,
         DOMString key,
         InteractionCallback callback);
+    
+    // Clicks at specific coordinates on the page
+    // |tabId|: The tab to click in. Defaults to active tab.
+    // |x|: X coordinate in CSS pixels from viewport origin.
+    // |y|: Y coordinate in CSS pixels from viewport origin.
+    // |callback|: Called when the click is complete.
+    static void clickCoordinates(
+        optional long tabId,
+        double x,
+        double y,
+        InteractionCallback callback);
+    
+    // Types text after clicking at coordinates to focus element
+    // |tabId|: The tab to type in. Defaults to active tab.
+    // |x|: X coordinate to click for focus.
+    // |y|: Y coordinate to click for focus.
+    // |text|: Text to type after focusing.
+    // |callback|: Called when the operation is complete.
+    static void typeAtCoordinates(
+        optional long tabId,
+        double x,
+        double y,
+        DOMString text,
+        InteractionCallback callback);
         
     // Captures a screenshot of the tab as a thumbnail
     // |tabId|: The tab to capture. Defaults to active tab.
     // |thumbnailSize|: Optional max dimension for the thumbnail. If not provided, uses viewport size.
     //                  The actual size will be the minimum of this value and the viewport dimensions.
+    //                  Ignored if width and height are specified.
+    // |showHighlights|: If true, shows bounding boxes around clickable, typeable, and selectable elements that are in viewport.
+    // |width|: Optional exact width for screenshot. When used with height, overrides thumbnailSize.
+    // |height|: Optional exact height for screenshot. When used with width, overrides thumbnailSize.
     // |callback|: Called with the screenshot as a data URL.
     static void captureScreenshot(
         optional long tabId,
         optional long thumbnailSize,
+        optional boolean showHighlights,
+        optional long width,
+        optional long height,
         CaptureScreenshotCallback callback);
 
     // Gets a content snapshot of the specified type from the page
@@ -335,6 +369,15 @@ namespace browserOS {
     // |callback|: Called with the version string.
     static void getVersionNumber(
         GetVersionNumberCallback callback);
+    
+    // Executes JavaScript code in the specified tab
+    // |tabId|: The tab to execute JavaScript in. Defaults to active tab.
+    // |code|: The JavaScript code to execute.
+    // |callback|: Called with the result of the execution.
+    static void executeJavaScript(
+        optional long tabId,
+        DOMString code,
+        ExecuteJavaScriptCallback callback);
   };
 };
 
diff --git a/extensions/browser/extension_function_histogram_value.h b/extensions/browser/extension_function_histogram_value.h
index 4ba734b8f5f0e..804539041fa01 100644
--- a/extensions/browser/extension_function_histogram_value.h
+++ b/extensions/browser/extension_function_histogram_value.h
@@ -2015,6 +2015,9 @@ enum HistogramValue {
   BROWSER_OS_GETALLPREFS = 1952,
   BROWSER_OS_LOGMETRIC = 1953,
   BROWSER_OS_GETVERSIONNUMBER = 1954,
+  BROWSER_OS_EXECUTEJAVASCRIPT = 1955,
+  BROWSER_OS_CLICKCOORDINATES = 1956,
+  BROWSER_OS_TYPEATCOORDINATES = 1957,
   // Last entry: Add new entries above, then run:
   // tools/metrics/histograms/update_extension_histograms.py
   ENUM_BOUNDARY
-- 
2.49.0

